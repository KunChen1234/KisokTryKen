import { ReadlineParser, SerialPort, DelimiterParser } from "serialport";
import parser from "./args_parser";
import sleep from "./sleep";

interface RoobuckTag {
	MAC: string;
	SN: string;
}
function isRoobuckTag(obj: unknown): obj is RoobuckTag {
	if (obj && typeof obj === "object") {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const parse = obj as Record<string, any>;
		return parse && typeof parse === "object" && !Array.isArray(parse) &&
			parse.MAC && typeof parse.MAC === "string" && parse.SN &&
			typeof parse.SN === "string";
	} else {
		return false;
	}
}

function intToBytes(num: number) {
	const arr = new ArrayBuffer(1);
	const view = new DataView(arr);
	view.setUint8(0, num);
	return arr;
}

/**
 * Write a string to the NFC tag. Scans for nearby tags first then writes the string desired 4 bytes at a time.
 * @param comPort SerialPort object connected to the USB NFC reader
 * @param input string to write into the NFC tag
 */
async function writeTag(comPort: SerialPort, input: string, dataParser: ReadlineParser): Promise<void> {
	const record = Buffer.concat([Buffer.from("en" + input), Buffer.from([0xFE])]); // Convert input to a buffer, append the byte '6D' to end the writing
	const length = record.length;
	const hlength = length + 4;
	const header = Buffer.concat([Buffer.from([0x03]), Buffer.from(intToBytes(hlength)), Buffer.from([0xD1, 0x01]), Buffer.from(intToBytes(length)), Buffer.from([0x54, 0x02])]);
	const buff = Buffer.concat([header, record])
	const comms: Array<string> = []
	// 	`200104${header.subarray(0,4).toString("hex")}`,
	// 	`200105${header.subarray(4,header.length).toString("hex")}`
	// ];
	let k = 0;
	let page = 4;
	// console.log(comms);
	/* 
		To write to the NFC tag we need to write into the "pages" of the tag, starting at page 4. Each page can
		encode 4 bytes so we send generate commands to write the desired text 4 bytes at a time, incrementing the page
		each time.
	*/
	while (k < buff.length) {
		let comm = "2001";
		if (page < 16) {
			comm += "0" + page.toString(16) + buff.subarray(k, k + 4).toString("hex");
		} else {
			comm += page.toString(16) + buff.subarray(k, k + 4).toString("hex");
		}
		comm = comm.padEnd(14, "0");
		comms.push(comm);
		k += 4;
		page++;
	}
	// comms.push(`2001${page}`)
	if (page < 16) {
		comms.push(`20010${page.toString(16)}00000000`);
	} else {
		comms.push(`2001${page.toString(16)}00000000`);
	}
	// console.log(comms);
	await command(comPort, "041007\r", dataParser);
	await command(comPort, "041101\r", dataParser);
	// eslint-disable-next-line no-constant-condition
	let runLoop = true;
	// let i = 0;
	setTimeout(() => {
		// Timeout to stop scanning for the loop
		console.log("Loop End");
		runLoop = false;
		process.exit(0);
	}, 15 * 1000); // Timeout after 15s

	while (runLoop) {
		// console.log(i, runLoop);
		try {
			const scanResult = await scanTag(comPort, dataParser);
			if (scanResult) {
				// console.log(scanResult);
				await command(comPort, "041107\r", dataParser);
				comms.forEach(async (comm) => {
					const writeResult = await command(comPort, comm + "\r", dataParser);
					// console.log(writeResult);
					if (!writeResult || !Buffer.isBuffer(writeResult) || writeResult.subarray(0, 4).toString() !== "0001") {
						console.log("Failed to write to tag");
						await command(comPort, "041207\r", dataParser);
						await command(comPort, "041101\r", dataParser);
						process.exit(1);
					}
				});
				break;
			}
		} catch (err) {
			console.error(err);
		}
		// i++;
	}
	await sleep(1000);
	const result = await readTag(comPort, dataParser, false); // Read tag to verify that it is correctly written.
	if (!result) {
		console.log("Unable to write to tag.")
		return
	}
	// console.log(result);
	const start = result.indexOf("{");
	const end = result.indexOf("}");
	if (start >= 0 && end > start) {
		try {
			const jsonInput = JSON.parse(input);
			const jsonResult = JSON.parse(result.substring(start, end + 1));
			if (isRoobuckTag(jsonResult) && isRoobuckTag(jsonInput) && jsonResult.MAC === jsonInput.MAC && jsonResult.SN === jsonInput.SN) {
				// success Beeps
				await command(comPort, "0407646005E3000400\r", dataParser); // Beep
				await command(comPort, "0407646007F401F401\r", dataParser); // Beep
				console.log("NFC Tag Written Successfully");
				await command(comPort, "041207\r", dataParser);
				process.exit(0);
			} else {
				console.log("Failed to write to tag");
				console.log(`Output \"${result}\" does not match input \"${input}\".`)
				// Failure Beeps
				await command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
				await command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
				await command(comPort, "041207\r", dataParser);
				process.exit(1);
			}
		} catch (err) {
			console.error(err);
			process.exit(1);
		}
	} else {
		console.log(`Output \"${result}\" does not match input \"${input}\".`)
		// Failure Beeps
		await command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
		await command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
		await command(comPort, "041207\r", dataParser);
		process.exit(1);
	}
}

/**
 * Write a string to the NFC tag. Scans for nearby tags first then writes the string desired 4 bytes at a time.
 * @param comPort SerialPort object connected to the USB NFC reader
 * @param input string to write into the NFC tag
 */
 async function writeRoobuckTag(comPort: SerialPort, input: string, dataParser: ReadlineParser): Promise<void> {
	const record = Buffer.concat([Buffer.from("en" + input), Buffer.from([0xFE])]); // Convert input to a buffer, append the byte '6D' to end the writing
	const length = record.length;
	const hlength = length + 4;
	const header = Buffer.concat([Buffer.from([0x03]), Buffer.from(intToBytes(hlength)), Buffer.from([0xD1, 0x01]), Buffer.from(intToBytes(length)), Buffer.from([0x54, 0x02])]);
	const buff = Buffer.concat([header, record])
	const comms: Array<string> = []
	// 	`200104${header.subarray(0,4).toString("hex")}`,
	// 	`200105${header.subarray(4,header.length).toString("hex")}`
	// ];
	let k = 0;
	let page = 4;
	// console.log(comms);
	/* 
		To write to the NFC tag we need to write into the "pages" of the tag, starting at page 4. Each page can
		encode 4 bytes so we send generate commands to write the desired text 4 bytes at a time, incrementing the page
		each time.
	*/
	while (k < buff.length) {
		let comm = "2001";
		if (page < 16) {
			comm += "0" + page.toString(16) + buff.subarray(k, k + 4).toString("hex");
		} else {
			comm += page.toString(16) + buff.subarray(k, k + 4).toString("hex");
		}
		comm = comm.padEnd(14, "0");
		comms.push(comm);
		k += 4;
		page++;
	}
	// comms.push(`2001${page}`)
	if (page < 16) {
		comms.push(`20010${page.toString(16)}00000000`);
	} else {
		comms.push(`2001${page.toString(16)}00000000`);
	}
	// console.log(comms);
	await command(comPort, "041007\r", dataParser);
	await command(comPort, "041101\r", dataParser);
	// eslint-disable-next-line no-constant-condition
	let runLoop = true;
	// let i = 0;
	setTimeout(() => {
		// Timeout to stop scanning for the loop
		// console.log("Loop End");
		runLoop = false;
		process.exit(0);
	}, 15 * 1000); // Timeout after 15s

	while (runLoop) {
		// console.log(i, runLoop);
		try {
			const scanResult = await scanTag(comPort, dataParser);
			if (scanResult) {
				// console.log(scanResult);
				await command(comPort, "041107\r", dataParser);
				comms.forEach(async (comm) => {
					const writeResult = await command(comPort, comm + "\r", dataParser);
					// console.log(writeResult);
					if (!writeResult || !Buffer.isBuffer(writeResult) || writeResult.subarray(0, 4).toString() !== "0001") {
						console.log("Failed to write to tag");
						await command(comPort, "041207\r", dataParser);
						await command(comPort, "041101\r", dataParser);
						process.exit(1);
					}
				});
				break;
			}
		} catch (err) {
			console.error(err);
		}
		// i++;
	}
	await sleep(1000);
	const result = await readTag(comPort, dataParser, false); // Read tag to verify that it is correctly written.
	if (!result) {
		console.log("Unable to write to tag.")
		return
	}
	// console.log(result);
	const start = result.indexOf("{");
	const end = result.indexOf("}");
	if (start >= 0 && end > start) {
		try {
			const jsonInput = JSON.parse(input);
			const jsonResult = JSON.parse(result.substring(start, end + 1));
			if (isRoobuckTag(jsonResult) && isRoobuckTag(jsonInput) && jsonResult.MAC === jsonInput.MAC && jsonResult.SN === jsonInput.SN) {
				// success Beeps
				await command(comPort, "0407646005E3000400\r", dataParser); // Beep
				await command(comPort, "0407646007F401F401\r", dataParser); // Beep
				console.log("NFC Tag Written Successfully");
				await command(comPort, "041207\r", dataParser);
				process.exit(0);
			} else {
				console.log("Failed to write to tag");
				console.log(`Output \"${result}\" does not match input \"${input}\".`)
				// Failure Beeps
				await command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
				await command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
				await command(comPort, "041207\r", dataParser);
				process.exit(1);
			}
		} catch (err) {
			console.error(err);
			process.exit(1);
		}
	} else {
		console.log(`Output \"${result}\" does not match input \"${input}\".`)
		// Failure Beeps
		await command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
		await command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
		await command(comPort, "041207\r", dataParser);
		process.exit(1);
	}
}

/**
 * Opens the USB port for communication
 * @param {string} port The name of the USB port the scanner is connected 
 * @returns {SerialPort} The SerialPort object interface with the NFC scanner
 */
 function openComPort(port: string, parser = false): [SerialPort, ReadlineParser | null] {
	const comPort = new SerialPort({path: port, baudRate: 9600}, (err: Error | null | undefined) => {
		if (err) {
			console.error(err.message);
			// console.log("Unable to open serial port, exiting");
			process.exit(1);
		}
	});
	if (parser) {
		const dataParser = comPort.pipe(new DelimiterParser({ delimiter: '\r', includeDelimiter: false }));
		return [comPort, dataParser]
	}
	return [comPort, null];
}

/**
 * Error callback to handle errors generated in serial communication
 * @param {Error | null | undefined} err The error object generated.
 * @returns 
 */
function spErrCB(err: Error | null | undefined): void {
	if (err) {
		console.error(err.message);
		// console.log("Unable to write to SerialPort");
	}
	return;
}

/**
 * Write command to NFC scanner and await the data returned.
 * @param {SerialPort} comPort SerialPort object connected to the USB NFC reader
 * @param {string} command The command to write to the NFC reader as buffer converted to a hex string
 * @returns {Buffer | Error | null | undefined} Buffer of the result from the reader. Otherwise Error or null if command failed.
 */
async function command(comPort: SerialPort, command: string, dataParser: ReadlineParser): Promise<Buffer | Error | null | undefined> {
	// Pipe the data through a parser until it finds the "\r" character. 
	// const dataParser = comPort.pipe(new SerialPort.parsers.Delimiter({ delimiter: "\r", includeDelimiter: false }));
	// console.log("Promise Made");
	return new Promise((resolve, reject) => {
		comPort.write(command);
		dataParser.once("data", (data: Buffer) => {
			// console.log("Promise Resolved");
			resolve(data);
		});
		// dataParser.once("error", (err: Error | null | undefined) => {
		// 	spErrCB(err);
		// 	console.log("Promise Rejected")
		// 	reject(err);
		// });
	});
}

/**
 * 
 * @param {SerialPort} comPort The SerialPort object connected to the TWN4 scanner
 * @returns {Boolean} Boolean of whether a tag was detected or not. On an unresolvable output False is returned
 */
 async function scanTag(comPort: SerialPort, dataParser: ReadlineParser): Promise<boolean> {
	return new Promise((resolve, reject) => {
		comPort.write("050010\r");
		dataParser.once("data", (data: unknown) => {
			if (!Buffer.isBuffer(data)) {
				// throw Error(`Expected output with type of Buffer but instead received ${typeof data}`);
				// console.log(data);
				reject(`Expected output with type of Buffer but instead received ${typeof data}`);
			}else if (data.subarray(0, 4).toString() === "0001") {
				resolve(true);
			} else if (data.subarray(0, 4).toString() === "0000") {
				resolve(false);
			} else {
				console.error("Unable to resolve output.");
				// console.log("Promise Rejected");
				reject("Unable to resolve output.");
			}
		});
	});
}

async function readTag(comPort: SerialPort, dataParser: ReadlineParser, beep = true): Promise<string | null> {
	// console.log("Starting Lights")
	await command(comPort, "041007\r", dataParser);
	await command(comPort, "041101\r", dataParser);
	// eslint-disable-next-line no-constant-condition
	while (true) {
		try {
			// console.log("Scanning")
			const result = await scanTag(comPort, dataParser);
			if (result) {
				await command(comPort, "041107\r", dataParser);
				const data = await command(comPort, "20020420\r", dataParser); // Read data encoded in tag
				if (data && Buffer.isBuffer(data) && data.subarray(0, 4).toString() === "0001" && data.length > 4) {
					// console.log(data.toString());
					const converted = Buffer.from(data.toString(), "hex");
					// console.log(converted.toString());
					const start = converted.indexOf(0x03);
					const end = converted.indexOf(0xFE);
					// console.log(start, end);
					let strCon: string;
					if (start >= 0 && end > start) {
						strCon = converted.subarray(start, end).toString("utf8").replace(/\0/g, "");
					} else {
						strCon = converted.toString("utf8").replace(/\0/g, "");
					}
					if (beep) {
						// success Beeps
						await command(comPort, "0407646005E3000400\r", dataParser); // Short low Beep
						await command(comPort, "0407646007F401F401\r", dataParser); // long high Beep
						await command(comPort, "041207\r", dataParser);
					}
					// console.log(strCon)
					return strCon;
				} else {
					if (beep) {
						await command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
						await command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
						await command(comPort, "041207\r", dataParser);
					}
					console.log("Failed to Read Tag data");
					return null;
				}
			}
		} catch (err) {
			console.error(err);
		}
	}
}

async function main() {
	const args = parser(process.argv);
	let nfcPort: string;
	if (args["cport"] && typeof args["cport"] === "string") {
		nfcPort = args["cport"];
	} else {
		// console.log(args);
		const nfcPorts = await SerialPort.list()
		// console.log(ports);
		const nfcPortInfo = nfcPorts.filter(port => {
			return port.vendorId === "09D8";
		});
		if (nfcPortInfo.length > 1) {
			console.warn("Multiple potential NFC Scanners detected. Selecting the first one");
			console.warn(nfcPortInfo[0]);
		} else if (nfcPortInfo.length === 0) {
			console.error("No NFC Reader detected.")
			process.exit(1);
		}
		nfcPort = nfcPortInfo[0].path;
	}
	// console.log("opening com port")
	const [comPort, dataParser] = openComPort(nfcPort, true);
	if (!dataParser) {
		return;
	}
	if (args["r"]) {
		// console.log("Reading Tags");
		readTag(comPort, dataParser);
	}
	if (args["w"] && typeof args["w"] === "string") {
		writeTag(comPort, args["w"], dataParser);
	}
}

if (require.main === module) {
	main();
}

export {
	parser,
	sleep,
	writeTag,
	scanTag,
	readTag,
	writeRoobuckTag,
	openComPort,
	RoobuckTag
}