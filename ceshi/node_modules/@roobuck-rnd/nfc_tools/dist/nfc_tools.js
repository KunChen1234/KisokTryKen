"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openComPort = exports.writeRoobuckTag = exports.readTag = exports.scanTag = exports.writeTag = exports.sleep = exports.parser = void 0;
const serialport_1 = require("serialport");
const args_parser_1 = __importDefault(require("./args_parser"));
exports.parser = args_parser_1.default;
const sleep_1 = __importDefault(require("./sleep"));
exports.sleep = sleep_1.default;
function isRoobuckTag(obj) {
    if (obj && typeof obj === "object") {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const parse = obj;
        return parse && typeof parse === "object" && !Array.isArray(parse) &&
            parse.MAC && typeof parse.MAC === "string" && parse.SN &&
            typeof parse.SN === "string";
    }
    else {
        return false;
    }
}
function intToBytes(num) {
    const arr = new ArrayBuffer(1);
    const view = new DataView(arr);
    view.setUint8(0, num);
    return arr;
}
/**
 * Write a string to the NFC tag. Scans for nearby tags first then writes the string desired 4 bytes at a time.
 * @param comPort SerialPort object connected to the USB NFC reader
 * @param input string to write into the NFC tag
 */
function writeTag(comPort, input, dataParser) {
    return __awaiter(this, void 0, void 0, function* () {
        const record = Buffer.concat([Buffer.from("en" + input), Buffer.from([0xFE])]); // Convert input to a buffer, append the byte '6D' to end the writing
        const length = record.length;
        const hlength = length + 4;
        const header = Buffer.concat([Buffer.from([0x03]), Buffer.from(intToBytes(hlength)), Buffer.from([0xD1, 0x01]), Buffer.from(intToBytes(length)), Buffer.from([0x54, 0x02])]);
        const buff = Buffer.concat([header, record]);
        const comms = [];
        // 	`200104${header.subarray(0,4).toString("hex")}`,
        // 	`200105${header.subarray(4,header.length).toString("hex")}`
        // ];
        let k = 0;
        let page = 4;
        // console.log(comms);
        /*
            To write to the NFC tag we need to write into the "pages" of the tag, starting at page 4. Each page can
            encode 4 bytes so we send generate commands to write the desired text 4 bytes at a time, incrementing the page
            each time.
        */
        while (k < buff.length) {
            let comm = "2001";
            if (page < 16) {
                comm += "0" + page.toString(16) + buff.subarray(k, k + 4).toString("hex");
            }
            else {
                comm += page.toString(16) + buff.subarray(k, k + 4).toString("hex");
            }
            comm = comm.padEnd(14, "0");
            comms.push(comm);
            k += 4;
            page++;
        }
        // comms.push(`2001${page}`)
        if (page < 16) {
            comms.push(`20010${page.toString(16)}00000000`);
        }
        else {
            comms.push(`2001${page.toString(16)}00000000`);
        }
        // console.log(comms);
        yield command(comPort, "041007\r", dataParser);
        yield command(comPort, "041101\r", dataParser);
        // eslint-disable-next-line no-constant-condition
        let runLoop = true;
        // let i = 0;
        setTimeout(() => {
            // Timeout to stop scanning for the loop
            console.log("Loop End");
            runLoop = false;
            process.exit(0);
        }, 15 * 1000); // Timeout after 15s
        while (runLoop) {
            // console.log(i, runLoop);
            try {
                const scanResult = yield scanTag(comPort, dataParser);
                if (scanResult) {
                    // console.log(scanResult);
                    yield command(comPort, "041107\r", dataParser);
                    comms.forEach((comm) => __awaiter(this, void 0, void 0, function* () {
                        const writeResult = yield command(comPort, comm + "\r", dataParser);
                        // console.log(writeResult);
                        if (!writeResult || !Buffer.isBuffer(writeResult) || writeResult.subarray(0, 4).toString() !== "0001") {
                            console.log("Failed to write to tag");
                            yield command(comPort, "041207\r", dataParser);
                            yield command(comPort, "041101\r", dataParser);
                            process.exit(1);
                        }
                    }));
                    break;
                }
            }
            catch (err) {
                console.error(err);
            }
            // i++;
        }
        yield (0, sleep_1.default)(1000);
        const result = yield readTag(comPort, dataParser, false); // Read tag to verify that it is correctly written.
        if (!result) {
            console.log("Unable to write to tag.");
            return;
        }
        // console.log(result);
        const start = result.indexOf("{");
        const end = result.indexOf("}");
        if (start >= 0 && end > start) {
            try {
                const jsonInput = JSON.parse(input);
                const jsonResult = JSON.parse(result.substring(start, end + 1));
                if (isRoobuckTag(jsonResult) && isRoobuckTag(jsonInput) && jsonResult.MAC === jsonInput.MAC && jsonResult.SN === jsonInput.SN) {
                    // success Beeps
                    yield command(comPort, "0407646005E3000400\r", dataParser); // Beep
                    yield command(comPort, "0407646007F401F401\r", dataParser); // Beep
                    console.log("NFC Tag Written Successfully");
                    yield command(comPort, "041207\r", dataParser);
                    process.exit(0);
                }
                else {
                    console.log("Failed to write to tag");
                    console.log(`Output \"${result}\" does not match input \"${input}\".`);
                    // Failure Beeps
                    yield command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
                    yield command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
                    yield command(comPort, "041207\r", dataParser);
                    process.exit(1);
                }
            }
            catch (err) {
                console.error(err);
                process.exit(1);
            }
        }
        else {
            console.log(`Output \"${result}\" does not match input \"${input}\".`);
            // Failure Beeps
            yield command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
            yield command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
            yield command(comPort, "041207\r", dataParser);
            process.exit(1);
        }
    });
}
exports.writeTag = writeTag;
/**
 * Write a string to the NFC tag. Scans for nearby tags first then writes the string desired 4 bytes at a time.
 * @param comPort SerialPort object connected to the USB NFC reader
 * @param input string to write into the NFC tag
 */
function writeRoobuckTag(comPort, input, dataParser) {
    return __awaiter(this, void 0, void 0, function* () {
        const record = Buffer.concat([Buffer.from("en" + input), Buffer.from([0xFE])]); // Convert input to a buffer, append the byte '6D' to end the writing
        const length = record.length;
        const hlength = length + 4;
        const header = Buffer.concat([Buffer.from([0x03]), Buffer.from(intToBytes(hlength)), Buffer.from([0xD1, 0x01]), Buffer.from(intToBytes(length)), Buffer.from([0x54, 0x02])]);
        const buff = Buffer.concat([header, record]);
        const comms = [];
        // 	`200104${header.subarray(0,4).toString("hex")}`,
        // 	`200105${header.subarray(4,header.length).toString("hex")}`
        // ];
        let k = 0;
        let page = 4;
        // console.log(comms);
        /*
            To write to the NFC tag we need to write into the "pages" of the tag, starting at page 4. Each page can
            encode 4 bytes so we send generate commands to write the desired text 4 bytes at a time, incrementing the page
            each time.
        */
        while (k < buff.length) {
            let comm = "2001";
            if (page < 16) {
                comm += "0" + page.toString(16) + buff.subarray(k, k + 4).toString("hex");
            }
            else {
                comm += page.toString(16) + buff.subarray(k, k + 4).toString("hex");
            }
            comm = comm.padEnd(14, "0");
            comms.push(comm);
            k += 4;
            page++;
        }
        // comms.push(`2001${page}`)
        if (page < 16) {
            comms.push(`20010${page.toString(16)}00000000`);
        }
        else {
            comms.push(`2001${page.toString(16)}00000000`);
        }
        // console.log(comms);
        yield command(comPort, "041007\r", dataParser);
        yield command(comPort, "041101\r", dataParser);
        // eslint-disable-next-line no-constant-condition
        let runLoop = true;
        // let i = 0;
        setTimeout(() => {
            // Timeout to stop scanning for the loop
            // console.log("Loop End");
            runLoop = false;
            process.exit(0);
        }, 15 * 1000); // Timeout after 15s
        while (runLoop) {
            // console.log(i, runLoop);
            try {
                const scanResult = yield scanTag(comPort, dataParser);
                if (scanResult) {
                    // console.log(scanResult);
                    yield command(comPort, "041107\r", dataParser);
                    comms.forEach((comm) => __awaiter(this, void 0, void 0, function* () {
                        const writeResult = yield command(comPort, comm + "\r", dataParser);
                        // console.log(writeResult);
                        if (!writeResult || !Buffer.isBuffer(writeResult) || writeResult.subarray(0, 4).toString() !== "0001") {
                            console.log("Failed to write to tag");
                            yield command(comPort, "041207\r", dataParser);
                            yield command(comPort, "041101\r", dataParser);
                            process.exit(1);
                        }
                    }));
                    break;
                }
            }
            catch (err) {
                console.error(err);
            }
            // i++;
        }
        yield (0, sleep_1.default)(1000);
        const result = yield readTag(comPort, dataParser, false); // Read tag to verify that it is correctly written.
        if (!result) {
            console.log("Unable to write to tag.");
            return;
        }
        // console.log(result);
        const start = result.indexOf("{");
        const end = result.indexOf("}");
        if (start >= 0 && end > start) {
            try {
                const jsonInput = JSON.parse(input);
                const jsonResult = JSON.parse(result.substring(start, end + 1));
                if (isRoobuckTag(jsonResult) && isRoobuckTag(jsonInput) && jsonResult.MAC === jsonInput.MAC && jsonResult.SN === jsonInput.SN) {
                    // success Beeps
                    yield command(comPort, "0407646005E3000400\r", dataParser); // Beep
                    yield command(comPort, "0407646007F401F401\r", dataParser); // Beep
                    console.log("NFC Tag Written Successfully");
                    yield command(comPort, "041207\r", dataParser);
                    process.exit(0);
                }
                else {
                    console.log("Failed to write to tag");
                    console.log(`Output \"${result}\" does not match input \"${input}\".`);
                    // Failure Beeps
                    yield command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
                    yield command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
                    yield command(comPort, "041207\r", dataParser);
                    process.exit(1);
                }
            }
            catch (err) {
                console.error(err);
                process.exit(1);
            }
        }
        else {
            console.log(`Output \"${result}\" does not match input \"${input}\".`);
            // Failure Beeps
            yield command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
            yield command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
            yield command(comPort, "041207\r", dataParser);
            process.exit(1);
        }
    });
}
exports.writeRoobuckTag = writeRoobuckTag;
/**
 * Opens the USB port for communication
 * @param {string} port The name of the USB port the scanner is connected
 * @returns {SerialPort} The SerialPort object interface with the NFC scanner
 */
function openComPort(port, parser = false) {
    const comPort = new serialport_1.SerialPort({ path: port, baudRate: 9600 }, (err) => {
        if (err) {
            console.error(err.message);
            // console.log("Unable to open serial port, exiting");
            process.exit(1);
        }
    });
    if (parser) {
        const dataParser = comPort.pipe(new serialport_1.DelimiterParser({ delimiter: '\r', includeDelimiter: false }));
        return [comPort, dataParser];
    }
    return [comPort, null];
}
exports.openComPort = openComPort;
/**
 * Error callback to handle errors generated in serial communication
 * @param {Error | null | undefined} err The error object generated.
 * @returns
 */
function spErrCB(err) {
    if (err) {
        console.error(err.message);
        // console.log("Unable to write to SerialPort");
    }
    return;
}
/**
 * Write command to NFC scanner and await the data returned.
 * @param {SerialPort} comPort SerialPort object connected to the USB NFC reader
 * @param {string} command The command to write to the NFC reader as buffer converted to a hex string
 * @returns {Buffer | Error | null | undefined} Buffer of the result from the reader. Otherwise Error or null if command failed.
 */
function command(comPort, command, dataParser) {
    return __awaiter(this, void 0, void 0, function* () {
        // Pipe the data through a parser until it finds the "\r" character. 
        // const dataParser = comPort.pipe(new SerialPort.parsers.Delimiter({ delimiter: "\r", includeDelimiter: false }));
        // console.log("Promise Made");
        return new Promise((resolve, reject) => {
            comPort.write(command);
            dataParser.once("data", (data) => {
                // console.log("Promise Resolved");
                resolve(data);
            });
            // dataParser.once("error", (err: Error | null | undefined) => {
            // 	spErrCB(err);
            // 	console.log("Promise Rejected")
            // 	reject(err);
            // });
        });
    });
}
/**
 *
 * @param {SerialPort} comPort The SerialPort object connected to the TWN4 scanner
 * @returns {Boolean} Boolean of whether a tag was detected or not. On an unresolvable output False is returned
 */
function scanTag(comPort, dataParser) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            comPort.write("050010\r");
            dataParser.once("data", (data) => {
                if (!Buffer.isBuffer(data)) {
                    // throw Error(`Expected output with type of Buffer but instead received ${typeof data}`);
                    // console.log(data);
                    reject(`Expected output with type of Buffer but instead received ${typeof data}`);
                }
                else if (data.subarray(0, 4).toString() === "0001") {
                    resolve(true);
                }
                else if (data.subarray(0, 4).toString() === "0000") {
                    resolve(false);
                }
                else {
                    console.error("Unable to resolve output.");
                    // console.log("Promise Rejected");
                    reject("Unable to resolve output.");
                }
            });
        });
    });
}
exports.scanTag = scanTag;
function readTag(comPort, dataParser, beep = true) {
    return __awaiter(this, void 0, void 0, function* () {
        // console.log("Starting Lights")
        yield command(comPort, "041007\r", dataParser);
        yield command(comPort, "041101\r", dataParser);
        // eslint-disable-next-line no-constant-condition
        while (true) {
            try {
                // console.log("Scanning")
                const result = yield scanTag(comPort, dataParser);
                if (result) {
                    yield command(comPort, "041107\r", dataParser);
                    const data = yield command(comPort, "20020420\r", dataParser); // Read data encoded in tag
                    if (data && Buffer.isBuffer(data) && data.subarray(0, 4).toString() === "0001" && data.length > 4) {
                        // console.log(data.toString());
                        const converted = Buffer.from(data.toString(), "hex");
                        // console.log("converterd"+converted.toString());
                        const start = converted.indexOf(0x03);
                        const end = converted.indexOf(0xFE);
                        // console.log(start, end);
                        let strCon;
                        if (start >= 0 && end > start) {
                            strCon = converted.subarray(start, end).toString("utf8").replace(/\0/g, "");
                        }
                        else {
                            strCon = converted.toString("utf8").replace(/\0/g, "");
                        }
                        if (beep) {
                            // success Beeps
                            yield command(comPort, "0407646005E3000400\r", dataParser); // Short low Beep
                            yield command(comPort, "0407646007F401F401\r", dataParser); // long high Beep
                            yield command(comPort, "041207\r", dataParser);
                        }
                        // console.log(strCon)
                        return strCon;
                    }
                    else {
                        if (beep) {
                            yield command(comPort, "0407646006E3000400\r", dataParser); // Short high Beep
                            yield command(comPort, "0407646004F401F401\r", dataParser); // long low Beep
                            yield command(comPort, "041207\r", dataParser);
                        }
                        console.log("Failed to Read Tag data");
                        return null;
                    }
                }
            }
            catch (err) {
                console.error(err);
            }
        }
    });
}
exports.readTag = readTag;
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        const args = (0, args_parser_1.default)(process.argv);
        let nfcPort;
        if (args["cport"] && typeof args["cport"] === "string") {
            nfcPort = args["cport"];
        }
        else {
            // console.log(args);
            const nfcPorts = yield serialport_1.SerialPort.list();
            // console.log(ports);
            const nfcPortInfo = nfcPorts.filter(port => {
                return port.vendorId === "09D8";
            });
            if (nfcPortInfo.length > 1) {
                console.warn("Multiple potential NFC Scanners detected. Selecting the first one");
                console.warn(nfcPortInfo[0]);
            }
            else if (nfcPortInfo.length === 0) {
                console.error("No NFC Reader detected.");
                process.exit(1);
            }
            nfcPort = nfcPortInfo[0].path;
        }
        // console.log("opening com port")
        const [comPort, dataParser] = openComPort(nfcPort, true);
        if (!dataParser) {
            return;
        }
        if (args["r"]) {
            // console.log("Reading Tags");
            readTag(comPort, dataParser);
        }
        if (args["w"] && typeof args["w"] === "string") {
            writeTag(comPort, args["w"], dataParser);
        }
    });
}
if (require.main === module) {
    main();
}
//# sourceMappingURL=nfc_tools.js.map